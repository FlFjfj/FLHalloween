"maingame" module

"control" useModule
"string" useModule
"opengl" useModule
"glutils" useModule
"program" useModule

"assets" useModule
"worldmap" useModule
"player" useModule

WORLD_WIDTH: 1424.0r32;
WORLD_HEIGHT: 728.0r32;

MainGame: {

  map: WorldMap;
  batch: spriteBatch;
  camera: WORLD_WIDTH WORLD_HEIGHT orthographicCamera;
  startTime: Real32;
  lastMonsterTime: Real32;
  player: Player;
  monsters: Monster Array;
  init: [
    system.getTime @lastMonsterTime set
    @batch.init
    @map.init
    @player.init
    Monster.init
  ] func;

  enterState: [
    1.0r32 0.0r32 0.0r32 0.0r32 glClearColor
  ] func;

  draw: [
    GL_COLOR_BUFFER_BIT glClear
    @camera.beforeDraw
    map.drawFloor
    #player.draw
    #monsters fieldCount [i monsters @ .draw] times
    objects: Int32 Natx Real32 Renderable Array;
    PLAYER_TYPE player storageAddress 1 player.state1 @ Renderable @objects.pushBack
    map.mapWidth [col: i;
      map.mapHeight [row: i;
        type: Int32; ptr: Natx; y: Real32; include: FALSE;
        col row map.staticMap @ @ (
          1 [TILE1_TYPE @type set FALSE !include]
          2 [TILE2_TYPE @type set TRUE !include]
          []
        ) case

        include [
          col row map.staticMapCoordinates @ @ storageAddress !ptr
          1 col row map.staticMapCoordinates @ @ @ copy !y
          type ptr y Renderable @objects.pushBack
        ] when
      ] times
    ] times
    
    player.pumpkins fieldCount [
      pumpkin: i player.pumpkins @;
      PUMPKIN_TYPE pumpkin storageAddress 1 pumpkin.position @ Renderable @objects.pushBack
    ] times

    monsters fieldCount [
      monster: i monsters @;
      MONSTER_TYPE monster storageAddress 1 monster.state1 @ Renderable @objects.pushBack
    ] times

    <: ["IS_RENDERABLE" has] [
      a:b:;;
      a.y b.y >
    ] pfunc;

    objectsRange: @objects makeArrayRange;
    @objectsRange.heapSort
    objects fieldCount [
      renderable: i objects @;
      renderable.type (
        PLAYER_TYPE [
          plr: renderable.ptr Player Cref cast;
          plr.draw
        ]

        MONSTER_TYPE [
          plr: renderable.ptr Monster Cref cast;
          plr.draw
        ]

        PUMPKIN_TYPE [
          plr: renderable.ptr Real32 2 Vector Real32 2 Vector Pumpkin Cref cast;
          plr.draw
        ]

        TILE1_TYPE [
        ]
        
        TILE2_TYPE [
           plr: renderable.ptr (Real32 Real32) Cref cast;
           plr WorldTiles.woodWall.draw
        ]
        []
      ) case
    ] times

  ] func;

  update: [
    time: system.getTime;
    time lastMonsterTime - 5.0r32 > [
      time @lastMonsterTime set
      Monster @monsters.pushBack
    ] when

    @map.update
    @player.update
    nMonsters: Monster Array;
    monsters fieldCount [
      i @monsters @ .update [
        i @monsters @ @nMonsters.pushBack
      ] when
    ] times

    nMonsters @monsters set
    @camera.update
  ] func;

  PLAYER_TYPE: 0;
  MONSTER_TYPE: 1;
  PUMPKIN_TYPE: 2;
  TILE1_TYPE: 3;
  TILE2_TYPE: 4;

  Renderable: [{
    virtual IS_RENDERABLE: ();
    type:ptr:y: copy; copy; copy;
  }] func;
};

PumpkinAnimatedShader: {
  shaderVert:
  "
  #version 330 core
  
  #define FRAME_COUNT 7.0
  #define FRAME_TIME 0.15
  
  layout (location = 0) in vec3 aPosition;
  layout (location = 1) in vec2 aCoord;

  uniform mat4 u_projTrans;
  uniform mat4 u_modelTrans;
  uniform float u_Time;
  
  out vec2 vCoord;
  flat out float vFrame;
  
  void main() {
    vFrame = int((u_Time - int(u_Time)) * FRAME_COUNT);
    vCoord = aCoord;
    gl_Position = u_projTrans * u_modelTrans * vec4(aPosition, 1.0);
  }
  ";

  shaderFrag:
  "
  #version 330 core

  #define FRAME_COUNT 7.0 
  
  precision mediump float;
  
  in vec2 vCoord;
  flat in float vFrame;
  
  out vec4 color;
  
  uniform sampler2D u_Texture;
  
  void main() {
    color = texture(u_Texture, vec2((vCoord.x + vFrame) / FRAME_COUNT), vCoord.y);
  }
  ";

};
