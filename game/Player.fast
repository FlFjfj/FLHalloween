"player" module

"control" useModule
"algebra" useModule

Player: [{
  speed: 400.0r32;
  texture: GLuint;
  shader: GLuint;
  projLoc: GLint;
  modelLoc: GLint;
  state0: (Real32 Real32);
  state1: (Real32 Real32);
  size: 150.0r32;

  init: [
    assets.playerBack copy !texture
    PlayerStaticShader.shaderVert PlayerStaticShader.shaderFrag ( ("u_modelTrans" @modelLoc) ("u_projTrans" @projLoc) ) loadShader !shader

    "Player model " print modelLoc print LF print
    "Player proj " print projLoc print LF print
  ] func;

  draw: [
    shader glUseProgram
    camera.getCombined GL_FALSE Nat8 cast 1i32 projLoc glUniformMatrix4fv
    coords: state0 state1 state0 - frameTime * +;
    texture coords unwind size size 0.0r32 modelLoc batch.draw
    0n32 glUseProgram
  ] func;

  update: [
    state1 @state0 set
    direction: (0.0r32 0.0r32) dynamic;
    RIGHT system.isKeyDown [
      1.0r32 0 @direction @ set
    ] when

    LEFT system.isKeyDown [
      -1.0r32 0 @direction @ set
    ] when

    UP system.isKeyDown [
      1.0r32 1 @direction @ set
    ] when

    DOWN system.isKeyDown [
      -1.0r32 1 @direction @ set
    ] when

    (0.0r32 0.0r32) direction = ~ [
      dir: direction normalize;
      change1: dir speed *;
      change: change1 FRAME_DURATION *;
      change state0 + @state1 set
    ] when
  ] func;
}] func;

PlayerStaticShader: {
  shaderVert:
  "
#version 330 core

  layout (location = 0) in vec3 aPosition;
  layout (location = 1) in vec2 aCoord;

  uniform mat4 u_projTrans;
  uniform mat4 u_modelTrans;

  out vec2 vCoord;
  
  void main() {
    vCoord = aCoord;
    gl_Position = u_projTrans * u_modelTrans * vec4(aPosition, 1.0);
  }
  ";

  shaderFrag:
  "
#version 330 core

  precision mediump float;
  
  in vec2 vCoord;
  out vec4 color;
  
  uniform sampler2D u_Texture;
  
  void main() {
    color = texture(u_Texture, vCoord);
  }
  ";

};
