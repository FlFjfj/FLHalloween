"worldmap" module

"control" useModule
"assets" useModule

WorldMap: [
  {
    staticMap:(
      (2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2)
      (2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2)
      (2 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2)
      (2 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2)
      (2 2 1 1 1 1 1 1 1 1 1 1 2 1 5 1 1 5 1 1 2 2)
      (2 2 1 1 1 1 1 1 1 1 1 1 1 1 5 1 1 1 5 1 2 2)
      (2 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 5 1 1 1 2 2)
      (2 2 1 1 1 1 3 3 1 1 1 1 1 1 1 1 1 1 1 1 2 2)
      (2 2 1 1 1 1 1 4 1 1 1 1 1 1 1 1 1 1 1 1 2 2)
      (2 2 1 1 1 1 1 4 1 1 1 1 1 1 2 1 1 1 1 1 2 2)
      (2 2 1 1 1 1 3 4 1 1 1 1 1 1 1 3 3 1 1 1 2 2)
      (2 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1 1 1 2 2)
      (2 2 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1 1 1 1 2 2)
      (2 2 1 1 1 1 1 1 1 1 1 1 1 1 1 4 4 1 1 1 2 2)
      (2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2)
      (2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2)
    );

    mapWidth: 0 staticMap @ fieldCount;

    mapHeight: staticMap fieldCount;

    mapCenterX: mapWidth 2 /;
    mapCenterY: mapHeight 2 /;

    staticMapCoordinates: (Real32 Real32) mapWidth mapHeight Matrix;

    R: 65i32;

    shader: GLuint;
    projLoc: GLint;
    modelLoc: GLint;

    init: [
      DefaultTileShader.shaderVert DefaultTileShader.shaderFrag ( ("u_modelTrans" @modelLoc) ("u_projTrans" @projLoc) ) loadShader !shader
      mapHeight [row: i dynamic;
        mapWidth [col: i dynamic;
          element: col row @staticMapCoordinates @ @;

          realR: R Real32 cast;
          x: 1.5r32 WorldTiles.width * col Real32 cast *
          row Int32 cast 2 mod Real32 cast WorldTiles.sqrt32h * + ;
          y: row Real32 cast WorldTiles.height * 2.0r32 / ;


          (x copy y copy) @element set

        ] times
      ] times

      centerCoords: mapCenterX mapCenterY @staticMapCoordinates @ @ copy;

      mapHeight [row: i dynamic;
        mapWidth [col: i dynamic;
          element: col row @staticMapCoordinates @ @;
          element centerCoords - @element set
        ] times
      ] times



    ] func;

    drawFloor: [
      shader glUseProgram
      camera.getCombined GL_TRUE Nat8 cast 1i32 projLoc glUniformMatrix4fv
      mapHeight [row: mapHeight  i - 1 -  dynamic;
        mapWidth [col: i dynamic;
          tileType: col row staticMap @ @;
          tileType 1 = [row col WorldTiles.woodTrack.draw ]  when # [row col WorldTiles.woodWall.drawFloor] if
          tileType 2 = [row col WorldTiles.woodWall.drawFloor] when
          tileType 3 = [row col WorldTiles.homeWallObj.drawFloor] when
          tileType 4 = [row col WorldTiles.homeTrack.draw] when
          tileType 5 = [ row col WorldTiles.graveWallTile.drawFloor] when
          
        ] times
      ] times
      0n32 glUseProgram
    ] func;


    drawObj: [
      shader glUseProgram
      camera.getCombined GL_TRUE Nat8 cast 1i32 projLoc glUniformMatrix4fv
      mapHeight [row: mapHeight i - 1 - dynamic;
        mapWidth [col: i dynamic;
          tileType: col row staticMap @ @;
          tileType 2 = [ row col  WorldTiles.woodWall.drawObj] when
          tileType 3 = [ row col WorldTiles.homeWallObj.drawObj] when
          
        ] times
      ] times
      0n32 glUseProgram
    ] func;


    update: [

    ] func;
  }
] func;

WorldTiles: {

  width: 150.0r32;
  height: 130.0r32;
  sqrt32h: 3.0r32 sqrt height * 2.0r32 /;

  init: [] func;

  woodTrack: {
    texture: assets.woodTrack;

    draw: [row: col: Int32 cast; Int32 cast;
      element: col row @staticMapCoordinates @ @;

      assets.woodTrack 0 element @ 1 element @ WorldTiles.width WorldTiles.height 0.0r32 modelLoc batch.draw
    ] func;
  };


  homeTrack: {
    texture: assets.homeTrack;

    draw: [row: col: Int32 cast; Int32 cast;
      element: col row @staticMapCoordinates @ @;

      assets.homeTrack 0 element @ 1 element @ WorldTiles.width WorldTiles.height 0.0r32 modelLoc batch.draw
    ] func;
  };


  woodWall: {
    drawFloor: [ row: col: Int32 cast; Int32 cast;
      element: col row @staticMapCoordinates @ @;

      assets.woodWallTile 0 element @ 1 element @ WorldTiles.width WorldTiles.height 0.0r32 modelLoc batch.draw
    ] func;

    drawObj: [ row: col: Int32 cast; Int32 cast;
      element: col row @staticMapCoordinates @ @;

      assets.woodWallObj 0 element @ 1 element @ WorldTiles.height 2.0r32 / + WorldTiles.width WorldTiles.height 2.0r32 * 0.0r32 modelLoc batch.draw
    ] func;


  };


  homeWallObj: {
    
    drawFloor: [ row: col: Int32 cast; Int32 cast;
      element: col row @staticMapCoordinates @ @;

      assets.homeWallTile 0 element @ 1 element @ WorldTiles.width WorldTiles.height 0.0r32 modelLoc batch.draw
    ] func;

    drawObj: [ row: col: Int32 cast; Int32 cast;
      element: col row @staticMapCoordinates @ @;

      assets.homeWallObj 0 element @ 1 element @ WorldTiles.height 2.0r32 / + WorldTiles.width WorldTiles.height 2.0r32 * 0.0r32 modelLoc batch.draw
    ] func;


  };
  
  
    graveWallTile: {
    
   
   drawFloor: [ row: col: Int32 cast; Int32 cast;
      element: col row @staticMapCoordinates @ @;

      assets.graveWallTile 0 element @ 1 element @ WorldTiles.width WorldTiles.height 0.0r32 modelLoc batch.draw
    ] func;
  

  };



};

DefaultTileShader: {
  shaderVert:
  "
#version 330 core

  layout (location = 0) in vec3 aPosition;
  layout (location = 1) in vec2 aCoord;

  uniform mat4 u_projTrans;
  uniform mat4 u_modelTrans;

  out vec2 vCoord;
  
  void main() {

    vCoord = aCoord;
    gl_Position = u_projTrans * u_modelTrans * vec4(aPosition, 1.0);
  }
  ";

  shaderFrag:
  "
#version 330 core

  precision mediump float;
  
  in vec2 vCoord;
  out vec4 color;
  
  uniform sampler2D u_Texture;
  
  void main() {
    color = texture(u_Texture, vCoord);
  }
  ";
};


#{{ 2, 0, 0, 0}, {0, 1/2, 0, 0}, {0, 0, 1, 0}, {0, 0, 0, 1}} . {{cos(-pi/4), sin(-pi/4), 0 , 0},{-sin(-pi/4), cos(-pi/4), 0 , 0}, {0, 0, 1, 0}, {0,0,0,1}}
